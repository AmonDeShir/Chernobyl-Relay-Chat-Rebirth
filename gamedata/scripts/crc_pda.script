--| Chernobyl Relay Chat GUI
--| By TKGP, Anchorpoint, Amon

local xml = CScriptXmlInit()
xml:ParseFile("pda_crc_chat.xml")

local SINGLETON = nil

--- returns the pda ui instance
--- @return CRCPda
function get_ui()
    SINGLETON = SINGLETON or CRCPda()
    return SINGLETON
end

--- loads information about the last selected channel from the save file
local start_channel = 1
function load_state(m_data)
	start_channel = m_data.prevChannel or 1
end

--- @alias Message { icon: string, text: string, title: string }

class "CRCPda" (CUIScriptWnd)
function CRCPda:__init() super()
	--- all mesages displayed inside the PDA
	--- @type Message[]
    self.messages = {}

	--- load last selected channel (data from the save file)
    self.channel = start_channel
	--- all available  channels
	self.table_channel = {
		"#crcr_english",
		"#crcr_english_rp",
		"#crcr_english_shitposting",
		"#crcr_russian",
		"#crcr_russian_rp",
		"#crcr_tech_support",
	}

	--- all users displayed inside the PDA
	--- @type table<string, string>
    self.users = {}

	--- cached icons
    --- @type table<string, string>
	self.known_icons = {}

	--- init gui
	self:init_controls()
end

-- initialise the interface.
function CRCPda:init_controls()
	self:SetWndRect(Frect():set(0, 0, 1024, 768))

    xml:ParseFile("pda_crc_chat.xml")
	xml:InitFrame("frame1", self)
	xml:InitFrame("frame2", self)
	xml:InitFrame("frame3", self)

	self.list_channel = crc_list.CRCList(xml, 'list_channel', self)
	self.list_channel.on_select = function(id) self:on_select_channel(id) end
    self:__init_channel_list()

    self.messages_caption = xml:InitTextWnd("messages_caption", self)
    self.messages_caption:SetText(game.translate_string('crc_pda_messages'))

    self.users_caption = xml:InitTextWnd("users_caption", self)
    self.users_caption:SetText(game.translate_string('crc_pda_users'))

    self.message_list = xml:InitScrollView("messages", self)
	self.user_list = xml:InitScrollView("users", self)

	self.edit_box = crc_textbox.CRCTextbox(xml, 'edit_box', self)
	self.edit_box.on_key_press = function(key) return self:handle_edit_key_press(key) end

	self.no_connection_error = xml:InitStatic("connection_lost", self)
	self.no_connection_error:Show(false)

	self.button_send = xml:Init3tButton('button_send', self)
	self:Register(self.button_send, 'button_send')
	self:AddCallback("button_send", ui_events.BUTTON_CLICKED, self.send, self)

	self.sort_by_date = xml:InitCheck('sort_by_date', self)
	self.use_cyrillic = xml:InitCheck('use_cyrillic', self)
	self.ignore_outsiders = xml:InitCheck('ignore_outsiders', self)

    self.messages = {}
end

--- add channels to the channel list and select the last selected one
function CRCPda:__init_channel_list()
    for i=1, #self.table_channel do
		self.list_channel:add_item(game.translate_string(self.table_channel[i]), i)
	end

	self.list_channel:select_item(self.channel)
end

--- called by the list_channel component, when changing the channel it informs EXE applications of about the change
--- @param channel number
function CRCPda:on_select_channel(channel)
	if self.channel ~= channel then
		self.channel = channel
		crc_io.send("Channel/%s", self.channel)
    end
end

--- load channel from the action message
--- @param value string
function CRCPda:load_channel_from_settings(value)
    self.channel = tonumber(value)
	self.list_channel:select_item(self.channel)
end

--- called by the edit_box component, when a key is pressed while typing in a textbox. Used to implement keyboard shortcuts when typing a message.
--- ff it returns true the edit_box will exit the edit mode.
--- @param key number
--- @return boolean
function CRCPda:handle_edit_key_press(key)
	--- close the pda when CHAT_KEY is pressed
	if key == crc_config.get().chat_key then
        crc_shortcut.on_key_release(key)
        return true
    end

	--- send message when enter pressed
	if key == DIK_keys.DIK_RETURN then
        self:send()
        return true
    end

	return false
end

--- send the message from the textbox to the EXE application via crc_io.
function CRCPda:send()
	local input = self.edit_box:get_text()
    news_manager.send_tip(db.actor, input, nil, nil, 1)

	if input and input ~= "" then
		self.edit_box:clear()
		crc_io.send("Message/%s/%s", db.actor:character_community(), input)
	end

	if crc_config.get().close_chat then
		crc_shortcut.hide_pda(crc_shortcut.load_pda())
	end
end

--- returns true when the Chat menu is displayed inside the PDA
--- @return boolean
function CRCPda:is_open()
    return self:IsShown()
end

--- updates the user list and messages
function CRCPda:update_ui()
	self:update_users()
	self:update_messages()
end

--- redraw the user list
function CRCPda:update_users()
	self.user_list:Clear()

	for name, is_in_game in pairs(self.users) do
		local user = xml:InitStatic("user", nil)
		is_in_game = is_in_game == "True"

		xml:InitStatic("user:icon", user):InitTexture(self.known_icons[name] or crc_user.unknown)
		xml:InitStatic("user:name", user):TextControl():SetText(name:sub(1, 20))
		local user_status = xml:InitStatic("user:status", user)

		if is_in_game then
			user_status:TextControl():SetText(game.translate_string("crc_ingame"))
			user_status:TextControl():SetTextColor(GetARGB(255, 128, 255, 154))
		else
			user_status:TextControl():SetText(game.translate_string("crc_notingame"))
			user_status:TextControl():SetTextColor(GetARGB(255, 255, 128, 128))
		end

		self.user_list:AddWindow(user, true)
		user:SetAutoDelete(true)
	end
end

--- redraw the displayed messages
function CRCPda:update_messages()
    self.message_list:Clear()

	for _, messageData in ipairs(self.messages) do
        local message = xml:InitStatic("message", nil)

        xml:InitStatic("message:image", message):InitTexture(messageData.icon)
        xml:InitStatic("message:date_static", message):TextControl():SetText(game.get_game_time():dateToString())
        xml:InitStatic("message:caption_static", message):TextControl():SetText(messageData.title)
        xml:InitStatic("message:text_static", message):TextControl():SetText(messageData.text)

	    self.message_list:AddWindow(message, true)
	 	message:SetAutoDelete(true)
	end
end

--- enters/exits connection lost mode
--- @param state boolean
function CRCPda:connection_lost(state)
    self.no_connection_error:Show(state)
    self.edit_box:enable(not state)
    self.button_send:Enable(not state)
	self.list_channel:enable(not state)
end

--- selects pda sound by message type
--- @param message_type string
--- @return string
function CRCPda:sound_picker(message_type)
	if message_type == game.translate_string("crc_info") then
		return "pda_welcome"

	elseif message_type == game.translate_string("crc_error") then
		return "pda_alarm"

	else
		return "pda_tips"
	end
end

--- adds recived message to pda chat and log
--- @param icon string
--- @param title string
--- @param text string
function CRCPda:add_message(icon, title, text)
    local max_messages = crc_config.get().max_messages_size
	local messages_len = size_table(self.messages)

	printf("max: %s type: %s, len: %s type %s", max_messages, type(max_messages), messages_len, type(messages_len))

	if messages_len > max_messages then
		for i=max_messages, messages_len, 1 do
			table.remove(self.messages, i)
		end
	end

    table.insert(self.messages, 1, {title = title, text = text, icon = icon})

	if self:is_open() then
		self:update_messages()
	else
		-- TODO -> Change give_game_news to custom news implementation
		db.actor:give_game_news(title, text, icon, 0, crc_config.get().news_duration)
	end

    if crc_config.get().news_sound then
		xr_sound.set_sound_play(db.actor:id(), self:sound_picker(title))
	end
end

--- Saves the player's icon, for later use 
--- (displaying messages sent by that player, user list).
--- @param name string
--- @param icon string
function CRCPda:save_icon(name, icon)
    self.known_icons[name] = icon
end

--- returns 
function CRCPda:get_user(user)
    return self.users[user]
end

function CRCPda:load_users(users)
    self.users = {}

    for k, v in users do
        self.users[k] = v
    end

    if self:is_open() then
        self:update_users()
    end
end